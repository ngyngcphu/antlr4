# Introduction
Simple Translation of Array of non-negative integers.

## I. Grammar
```antlr
grammar ArrayInit;

init: '{' value (',' value)* '}';
value: init | INT;

INT: [0-9]+;
WS: [ \t\r\n]+ -> skip;
```
Run ANTLR tool on the grammar file
```
antlr4py3 ArrayInit.g4
```
For grammar `ArrayInt`, ANTLR generates lots of files that we'd normally have to write by hand:
1. **ArrayInitParser.py**: This file contains the parser class definition specific to
grammar ArrayInit that recognizes our array language syntax.
2. **ArrayInitLexer.py**: This file contains the lexer class definition, which ANTLR generated by analyzing the lexical rules INT and WS as well as the grammar literals '{', ',', and '}'.
3. **ArrayInit.tokens**: ANTLR assigns a token type number to each token we define and stores these values in this file.
4. **ArrayInitListener.py**: By default, ANTLR parsers build a tree from the input. By walking that tree, a tree walker can fire “events” (callbacks) to a listener object that we provide. ArrayInitListener is the interface that describes the callbacks we can implement.

## II. Testing the Generated Parser
To test our grammar, we use `pygrun`. Here's show to print out the tokens created by lexer:
```
pygrun ArrayInit init --tokens input.txt
```
Result:
```
[@0,0:0='{',<1>,1:0]
[@1,1:2='99',<4>,1:1]
[@2,3:3=',',<2>,1:3]
[@3,5:5='3',<4>,1:5]
[@4,6:6=',',<2>,1:6]
[@5,8:10='451',<4>,1:8]
[@6,11:11='}',<3>,1:11]
[@7,12:11='<EOF>',<-1>,1:12]
```
To learn more about how the parser recognized the input, we can ask for the parse tree with the `--tree` option:
```
pygrun ArrayInit init --tree input.txt
```
Result:
```
(init { 
   (value 99) , 
   (value 3) , 
   (value 451) })
```

### III. Integrating a Generated Parser into a Python Program
1. Import ANTLR's runtime library, Lexer and Parser generated from ANTLR tool
    ```py
    from antlr4 import *
    from target.ArrayInitLexer import ArrayInitLexer
    from target.ArrayInitParser import ArrayInitParser
    ```
2. Create a FileStream that reads from input file
    ```py
    istream = FileStream(argv[1])
    ```
3. Create a lexer that feeds off of input FileStream
    ```py
    lexer = ArrayInitLexer(istream)
    ```
4. Create a buffer of tokens pulled from the lexer
    ```py
    stream = CommonTokenStream(lexer)
    ```
5. Create a parser that feeds off the tokens buffer
    ```py
    parser = ArrayInitParser(stream)
    ```
6. Begin parsing at init rule
    ```py
    tree = parser.init()
    ```
7. Print LISP-style tree
    ```py
    print(tree.toStringTree(recog=parser))
    ```

Here's how to run test:
```
python3 test.py input.txt
```
Result:
```
(init { (value 1) , (value (init { (value 2) , (value 3) })) , (value 4) })
```

### IV. Building a Language Application
Convert short array inits like {1,2,3} to "\u0001\u0002\u0003".
- Translate { to ".
- Translate } to ".
- Translate integers to four-digit hexadecimal strings prefixed with \u.

The listener implementation for our translation rules in `short_to_unicode_string.py`. The only thing left to do is to create a translator application derived from the `test` boilerplate code shown earlier.
1. Create a generic parse tree walker that can trigger callbacks:
    ```py
    walker = ParseTreeWalker()
    ```
2. Walk the tree created during the parse, trigger callbacks:
    ```py
    walker.walk(ShortToUnicodeString(), tree)
    ```
Try it on our sample input:
```
python3 test.py input.txt
```
Result:
```
(init { (value 1) , (value (init { (value 2) , (value 3) })) , (value 4) })
"\u0001"\u0002\u0003"\u0004"
```